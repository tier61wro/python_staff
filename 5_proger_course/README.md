![Alt text](0_img/pylogo.png?raw=true "Title")
# ссылка на курс: #
https://itproger.com/course/python/1
# Content table # 
- [Уроки](#Уроки)
    - [3.Диагностика ошибок](#3-типы-ошибок)
    - [4 Переменные test](#4-переменные)
    - [5 Условные операторы](#5-условные-операторы)
    - [6 Циклы For, While, а также операторы](#6-циклы-и-операторы)
    - [7 Списки](#7-списки)
    - [8 Индексы срезы](#8-индексы-срезы)
    - [9 Кортежи](#9-кортежи-tuple)
    - [10 Словари](#10-словари-dict)
    - [11 Множества](#11-множества-set)
    - [12 Функции](#12-функции)

## Уроки ##
### урок3 ###
![Alt text](0_img/errors.png?raw=true "Title")

### 4 Переменные ###

В ходе самой программы мы можем перезаписывать значение переменной, при этом мы можем указывать новый тип переменной. К примеру, изначально был записан тип float, но потом можно записать другой тип данных:
```python
first_num = 23.2 # Тип данных float
first_num = "1" # Тип данных String
```
Тем не менее, если мы попытаемся сложить две переменные с разными типами данных, то это вызовет ошибку.

```python
first_num = "Some"
second_num = 21
res = first_num + second_num # Здесь будет ошибка
```
Ниже приводим все существующие типы данных в языке Python:

```python
some = 1 Integer - целые числа
some = 1.12 Float - числа с плавающей точкой
some = "Привет" String - строки
```

Есть и другие типы, но их мы будем разбирать в последующих уроках.

Также можно присваивать сразу несколько переменных:
```python
first = sec = third = 1 # Всем трем переменным будет присвоено значение 1
first, sec, third = "Hi", 75, 23.1 # Поочередное присвоение значений
```
### 5 Условные операторы ###
Условные операторы помогают проверить несколько значений и выполнить код в зависимости от итога проверки. Вы можете создавать вложенные условные операторы, которые будут дополнительно проверять данные. Также можно проверять несколько условий в одном операторе. К примеру, чтобы проверить сразу два условия в одном операторе потребуется использовать операцию and (логическое и):
```python
a = 2
if a != 0 and a != 1:
   print ("Проверка сработала")
```
Эта проверка сработает лишь в том случае, если оба условия окажутся как истинными (true).

Также можно проверять при помощи логического или or. В этом случае если хотя бы одно условие является верным (true), то код внутри условия будет выполнен:
```python 
a = 1.1
if a != 1.1 or a > 0:
   print ("Проверка сработала")
```
Операции на условие:
```python
num = input ("Введите число: ")

if int (num) > 0:
	if int (num) > 10:
		print ("Вы ввели число больше 10")
		if int (num) >= 50:
			print ("Вы ввели число больше 50")
	else:
		print ("Вы ввели число меньше 10 и больше 0")
elif int (num) < -10:
	print ("Вы ввели число меньше -10")
else:
	print ("Вы ввели число меньше 0 и больше -10")
print ("All is okay!")

name = input ()
A = 'Yes' if name != "Test" else 'No'
print (A)
```
#### 6 Циклы и операторы ####
Циклы позволяют выполнять некий код несколько раз подряд. Это особенно полезно при работе с массивами. В языке Python циклы немного отличаются по своему виду от циклов в других языках. К примеру, во многих языках есть цикл do..while, который выполняется один раз сто процентов, а потом проверяет условие. В питоне его нет- но можно заменить.

Также важно отметить, что вы можете создать бесконечный цикл, но с оператором break, который выйдет из цикла:
```python
a = 10
while True:
  a -= 1
  if a == 0:
    break
```
Такой цикл сработает корректно, так как у нас есть оператор break, который сработает в нужный момент и выйдет из цикла.
Пример кода с циклами
```python
i = 1000
while i > 100:
	print (i)
	i /= 2

for j in 'hello world':
	if j == 'w':
		break
else:
	print ("Буквы а нету в слове")
```
#### 7 Списки ####
Списки можно также назвать массивами, так как выполняют они схожую роль. В Python существует множество разновидностей таких "массивов". В уроке мы рассмотрели лишь первый тип, который называется списком и имеет следующие характеристики:
его элементы можно переопределять;
в него можно добавлять новые элементы;
из него можно удалять элементы;
в качестве ключей идут индексы (числа - 0, 1, 2...).
Это не все характеристики списка, тем не менее это ключевые моменты, которые отличают его от других "массивов" в языке Python.

Для списков существует большое количество функций, которые можно применять для добавления, удаления или же поиска элементов.

Пример создания списка:

```python
lis = ["Андрей", "Иван", "Василий", "Петро", "Максим", "Дима"]
```
```python
l = []
lis = [1, 56, 'x', 34, 2.34, ['S', 't', 'r', 'o', 'k', 'a']]
print (lis)

a = [a + b for a in 'list' if a != 's' for b in 'soup' if b != 'u']
print (a)

l.append (23)
l.append (34)
b = [24, 67]
l.extend (b) # все элемены b расширяют l
#i>>> print (l)
#[23, 34, 24, 67]
l.insert (1, 56)
l.append (34)
l.remove (34)
l.pop (0)
print (l.index (56))
print (l.count (34))
l.sort ()
l.reverse ()
l.clear ()

print (l)
```

#### 8 Индексы и срезы ####
Нумерация в списках начинается с нуля, так как список по большей части своей это просто массив, то как в обычном массиве отсчет ведется от 0. Поэтому первый элемент по индексу будет 0, второй - 1, третий - 2 и так далее. Если мы попытаемся взять несуществующий элемент, то это приведет к ошибке.
```python
a = [0, 23, "Hi"] # Список
print (a[4]) # Выдаст ошибку, так как элемента не существует
```
Очень удобной функцией языка Python является возможность брать элементы с конца при помощи отрицательных индексов. К примеру, если нам нужен второй элемнет с конца, то мы можем записать это так:
```python
a = [0, 23, "Hi", 1.56, 9] # Список
print (a[-2]) # Будет выведено 1.56
```
Срезы
Срезы позволяют обрезать список, взяв лишь те элементы, которые нам будут нужны. Они работают по следующей схеме: list[НАЧАЛО:КОНЕЦ:ШАГ].
Начало - с какого элемента стоит начать (по умолчанию равна 0);
Конец - по какой элемент мы берем элементы (по умолчанию равно длине списка);
Шаг - с каким шагом берем элементы, к примеру каждый 2 или 3 (по умолчанию каждый 1).
Один, несколько или даже все параметры могут быть пропущены.
```python
list[::3] # Берем каждый третий элемент
list[2::2] # Начиная со второго элемента берем каждый второй элемент
list[4:6:] # Начиная с 4 элемента берем все элементы по 6 элемент
list[::] # Берем все элементы
```
Также могут быть использованы отрицательные числа для срезов.
```python
l = [34, 'sd', 56, 34.34]

i = 0
while i < 4:
	print (l[i])
	i += 1
	
print (l[-2::-2])
```

#### 9 Кортежи tuple ####
Кортежи это по сути те же самые списки, только с несколькими отличиями. Кортежи нельзя изменять после их создания, а также они весят чуть меньше, чем списки.

При работе с кортежами действуют абсолютно все методы, о которых было рассказано в уроке про списки. Единственные методы, которые не будут работать, так это методы изменяющие кортеж: удаление, добавление элементов, сложение кортежей и тому подобные.

Кортежи можно создать двумя способами:
```python
a = tuple ('hello') # при помощи клчевого слова tuple разбиваем слово на список
a = ('a','b') # при помощи литерала
```
Их главное преимущество в том, что их нельзя изменять, поэтому ни вы, ни кто-либо другой не сможет как случайно, так и намерено изменить кортеж.

#### 10 Словари dict ####
Словари отличаются способом записи их, а также индексами. Если в обычном списке в качестве индексов выступают числа (0, 1, 2...), то здесь на их замену приходят "ключи". Так, мы можем создать некий ключ (Студент Федя, например) и добавить к нему целый ряд характеристик (список) в качестве одного элемента. Теперь найти нужного нам студента будет намного проще, так как мы просто будет оперировать ключами, а не числами.

Во многих других языках программирования такие словари зачастую называются ассоциативными массивами, поэтому не редко можно услышать и такое название.

Чтобы создать словарь вы можете воспользоваться следующей конструкцией:
```python
d0= {'test' : 1, 'prod': 2}
d1= dict (short = 'dict', longer = 'dictionary')
d2= dict ([(23,34),(56,87)])
d3= dict.fromkeys(['a','b'], 3)
```
Методы словарей:
```python
dict.clear() # очистка словаря
dict.copy() # возвращает копию словаря
dict.fromkeys(seq[,value]) # создает словарь с ключами из seq и значениям value
dict.get(key[,default]) # возвращает значение ключа, если ключа нет - возвращаем default
dict.items() # возвращает пары ключ - значени
dict.keys() # вернуть ключи
dict.pop(key,[,default]) # удаляет ключ и возвращает значение. Если ключа нет, возвращает default (вместо исключения по умолчанию)
dict.popitem() # удаляет и возвращает пару (ключ - значение)
dict.setdefault(key[,default])  - возвращает значение ключаб если его нет - создает ключ с default
dict.update([other]) # обновляет словарь, добавляя пары из other. Существующие ключи перезаписываются. Возвращает None.
dict.values() #  возвращает значения в словаре
```

Применение словарей в Python:
```python
d = {a : a ** 2 for a in range(7)}
print (d)

person = {'name' : {'last_name': 'Иванов', 'first_name': 'Иван', 'middle_name': 'Иванович'}, 'address': ['г. Андрюшки', 'ул. Васильковская д. 23б', 'кв.12'], 'phone': {'home_phone': '34-67-12', 'mobile_phone': '8-564-345-23-65', 'mobile_phone_2': 'Нет'}}
# print (person['phone']['mobile_phone'])

print (person.keys ())
```
#### 11 Множества set  ####
Множества также схожи с массивами, но есть несколько отличий. Во-первых, множества создаются в абсолютно случайном порядке каждый раз. Вы можете разместить элементы как вам будет угодно, но они все равно будут расположены впоследствии в случайном порядке. Во-вторых, множества не могут иметь повторяющихся элементов, поэтому все элементы, которые будут одинаковыми не будут выведены повторно.

Их очень удобно использовать, если вы хотите удалить повторяющиеся элементы из списка, например:
```some_list = [12, 56, 91, 12]
set(some_list) # Результат: 12, 56, 91
```
Также для существует огромное множество операций, которые приведены ниже:
```
len(s) - число элементов в множестве (размер множества).
x in s - принадлежит ли x множеству s.
set.isdisjoint(other) - истина, если set и other не имеют общих элементов.
set == other - все элементы set принадлежат other, все элементы other принадлежат set.
set.issubset(other) или set <= other - все элементы set принадлежат other.
set.issuperset(other) или set >= other - аналогично.
set.union(other, ...) или set | other | ... - объединение нескольких множеств.
set.intersection(other, ...) или set & other & ... - пересечение.
set.difference(other, ...) или set - other - ... - множество из всех элементов set, не принадлежащие ни одному из other.
set.symmetric_difference(other); set ^ other - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
set.copy() - копия множества.
```

С множествами можно выполнять множество операций: находить объединение, пересечение...

#### 12 Функции ####

Функции можно назвать небольшими подпрограммами, куда можно вынести повторяющийся код и обращаться к нему, когда это будет нужно. Функции значительно облегчают построение программ, так как нам не надо копировать однотипный код множество раз, а можно просто воспользоваться одной общей функцией.

В Python функции создаются при помощи ключевого слова def. Каждая функция может иметь какие-либо параметры или же не иметь их вовсе. Также функции способны что-либо возвращать в ходе выполнения кода в них или же ничего не возвращать.

```python
def some_test(): # Функция без параметров
    x = 23
    return x # Функция возвращает что-либо

def some_test_2(a, b, c): # Функция с 3 параметрами
    return a * b * c # Функция возвращает результат умножение чисел

def print_something(word, prefix): # Функция с 2 параметрами
    print (prefix, "-", word)
    pass # Функция ничего не возвращает
```
Когда функция ничего не возвращает, то необходимо прописывать ключевое слово pass. Также функции могут возвращать другие функции, тем самым вызывая их. Чтобы обратиться к функции необходимо прописать её названи и передать параметры, если таковы имеются

```python
res = some_test_2 (2, 67, 12)
```
Здесь мы все записываем в переменную res, так как функция вернет результат, который мы можем куда-то поместить.
Если функция не должна выполнять большой объем кода, то можно воспользоваться анонимной функцией. Для этого нам потребуется функция lambda. Пример создания такой функции:
```python
multiple = lambda a, b: a * b
multiple(7, 12)
```
Такая функция не имеет названия, но её можно присвоить к переменной, которую в дальнейшем необходимо вызывать как обычную функцию.
Примеры функций

```python
def func (**args):
	return args

print (func (short='dict', longer='dictionary'))

add = lambda x, y: x * y
print (add (2, 5))
print (add ('q', 5))

print ((lambda x, y: x * y)(2, 6))

fun = lambda *args: args
print (fun (2, 56, 78.56))
```
#ЗАДАНИЯ
```python
#Ваша задача сделать функцию, которая будет принимать 2 параметра (время и скорость) и возвращать сколько проедет километров человек исходя из параметров. Теперь вам необходимо вывести это на экран. Если человек проехал 1 километр, то писать так: "Вы проедете: 1 километр", иначе писать так: "Вы проедете: {здесь цифра} километров". Последнее выполнить через lambda

def count_distance (v, t):
    print ("скорость = ", v)
    print ("время = ", t)
    return v*t

s = count_distance(1,1);
back_mess = (lambda a: "kilometr" if a == 1 else "kilometrov")(s)
print ("Вы проедете: ", s, back_mess )

# Создайте функцию, которая будет принимать параметр и внутри этой функции будет еще одна функция, которая также будет принимать параметр. Вторая функция должна просто суммировать оба параметра, а первая должна вернуть результат.

def funk1(par1):
    def funk2(par2):
        return par1 + par2
    return funk2

summa_sotka_funk = funk1(100)
res = summa_sotka_funk(200)
print ("res = ", res)

#Создайте функцию с параметрами по умолчанию. Вызовите эту функцию и передайте в нее не все параметры. Функция должна вернуть деление всех чисел. При этом добавьте проверку при деления на ноль.

def chastnoe (a,b,c = 1):
    if ((a == 0) or (b == 0) or (c == 0 )):
        print ("alarm")
    else:
        return int(a/b/c)

diff = chastnoe (8,4)
print ("diff=", diff)

#Создайте функцию, которая может принимать не установленное количество параметров. Выведите сумму всех переданных параметров.
def many_params (*params):
    res_sum = 0
    for i in params:
        print ("i=",i)
        res_sum += i
    return res_sum

list = (3,6)
print (many_params(3,5))

#Создайте анонимную функцию с неустановленным количеством параметров. Функция должна выводить все параметры на экран.
anon_funk = lambda *args: print (args)
anon_funk(3,7)
```
#### 13 Исключения ####
Исключения это то, что может непредвиденно возникнуть в ходе работы программы. Если такое случится, то программа просто завершит свою работу. Чтобы такого не допустить вам всегда стоит добавлять исключения. К примеру, вы хотите добавить возможность деления двух чисел? Добавьте также исключение, которое позволит проверять, не является ли делитель нулем. Или же вы хотите что-то вписать файл, но для начала его необходимо открыть. Пропишите исключение, которое будет срабатывать если файл не найден, чтобы программа не пыталась его открывать повторно.
Конструкция самих исключений очень проста. Вам необходимо сначала что-то попробовать сделать, а потом поискать ошибку, если она будет найдена, то выведется ваш код, иначе все сработает корректно и никаких ошибок не будет.

```
      +-- StandardError
      |    +-- BufferError
      |    +-- ArithmeticError
      |    |    +-- FloatingPointError
      |    |    +-- OverflowError
      |    |    +-- ZeroDivisionError
      |    +-- AssertionError
      |    +-- AttributeError
      |    +-- EnvironmentError
      |    |    +-- IOError
      |    |    +-- OSError
      |    |         +-- WindowsError (Windows)
      |    |         +-- VMSError (VMS)
      |    +-- EOFError
      |    +-- ImportError
      |    +-- LookupError
      |    |    +-- IndexError
      |    |    +-- KeyError
      |    +-- MemoryError
      |    +-- NameError
      |    |    +-- UnboundLocalError
      |    +-- ReferenceError
      |    +-- RuntimeError
      |    |    +-- NotImplementedError
      |    +-- SyntaxError
      |    |    +-- IndentationError
      |    |         +-- TabError
      |    +-- SystemError
      |    +-- TypeError
      |    +-- ValueError
      |         +-- UnicodeError
      |              +-- UnicodeDecodeError
      |              +-- UnicodeEncodeError
      |              +-- UnicodeTranslateError
```

```python
try:
    a = 2/3
except ArithmeticError:
    print("Something went wrong")
except ArithmeticError:
    print("Some other error") # дефолтный всегда последний
else:
    print("Nothing went wrong")
finally:
    print ("end of work")
```

#ЗАДАНИЯ:
```python
#Попросите пользователя ввести возраст, если он ввел не возраст, то скажите ему об этом и попросите сделать это еще раз. Сделайте это в цикле, чтобы каждый раз спрашивался возраст, пока пользователь его наконец не введет

age_int = None
while (age_int == None):
    try:
        age_int = int(input("insert age\n"))
    except:
        print ("age is not ok")
    else:
        print ("ok")

#Создайте исключение, которое сработает при использовании несуществующей переменной. К примеру, вы хотите присвоить значение несуществующей переменной к другой переменной. Такое исключение носит название NameError.

try :
    #exist = unexist + 1
    res = 3/1
except NameError:
    print ("smth bad")
except ZeroDivisionError:
    print ("zero div")
else:
    print ("ok")

#Допустим вы хотите вызвать функцию, но не знаете существует ли она. Создайте исключение, которое будет выдавать ошибку, если функции не существует.
try:
    bad_func(3)
except NameError:
    print ("bad f")
```
#### 14 файлы ####
Для открытия файла существует функция open, которая открывает файл разными способами. Вот все возможные типы открытия файла:
```
'r' открытие на чтение (является значением по умолчанию).
'w' открытие на запись, содержимое файла удаляется, если файла не существует, создается новый.
'x' открытие на запись, если файла не существует, иначе исключение.
'a' открытие на дозапись, информация добавляется в конец файла.
'b' открытие в двоичном режиме.
't' открытие в текстовом режиме (является значением по умолчанию).
'+' открытие на чтение и запись
```
Для записи текста в файл существует метод write, а для чтения метод read. После того, как с файлом была закончена работа его обязательно необходимо закрыть. Это делается при помощи метода close. 

```python
f = open ('text.txt', 'w')
f.write ('Hi, it's me!
Test')
f.close ()
for line in f:#аналог перлового while
    print (line)
```
```python
#каноническое открытие большого файла в питоне
with open("x.txt") as f:
    for line in f:
        do something with data
```
#ЗАДАНИЯ:
```python
#Создайте файл hi.txt и поместите туда строку "Какая-угодно информация!" и закройте файл.
#Откройте файл только для чтения и выведите информацию на экран.
f = open('file.txt', 'w+') # если r+ то файл не создастся
f.write('Какая-угодно информация3!')
f.seek(0)
a = f.read();
print ("a=", a)

#Постарайтесь открыть файл, которой вы не создавали. Создайте исключение, которое сработает при не нахождении такого файла. Такое исключение называется FileNotFoundError.
try:
    f=open("unexist_file", 'r')
except FileNotFoundError:
    print ("second error")
except: #default exept must be last or error
    print ("error with file open")

#Создайте файл "example.txt" и впишите туда текст "Привет" после чего закройте его. Теперь постарайтесь открыть этот же файл при помощи команды "x", которая открывает файл для чтения, если такого нет. Вам будет выдана ошибка, которую вы должны обработать в исключении. Ошибка будет называться FileExistsError. В finally пропишите закрытие файла, а в except пропишите верное открытие файла при помощи 'a'
file_name = "example.txt";
f = open (file_name, 'w')
f.write('some info')

try:
    f = open (file_name, 'x')
except FileExistsError:
    print ("error was excepted")
    f = open (file_name, 'a')
finally:
   f.close ()
```
#### 15 with as ####
Конструкция with ... as используется для оборачивания выполнения блока инструкций менеджером контекста. Иногда это более удобная конструкция, чем try...except...finally.
Для чего применяется конструкция with ... as? Для гарантии того, что критические функции выполнятся в любом случае. Самый распространённый пример использования этой конструкции - открытие файлов. 
```python
with open('newfile.txt', 'w', encoding='utf-8') as g:
    d = int(input())
    print('1 / {} = {}'.format(d, 1 / d), file=g)
```

#### 16 модули ####
Чтобы подключить модуль вам необходимо использовать команду import и указать название модуля.
```python
import time # Импорт одного модуля
import random, os # Импорт нескольких модулей
```
Также вы можете создавать свои модули. Вам просто необходимо создать новый файл и по его названию в дальнейшем вы сможете подключать этот файл как модуль к программе.

##### from #####
Чтобы импортировать лишь некоторые методы или же переменные можно использовать команду from. Эта команда записывается следующим образом:
```python
from math import ceil # Импортируем лишь метод ceil
```
##### Псевдонимы для модулей #####
Также при работе с модулями можно использовать псевдонимы. Это позволяет сократить название модуля, если оно слишком большое и вам не хочется писать его каждый раз.
```python
import Template as tem # Теперь можно обращаться к модулю как tem
```
!!!TODO тут хорошо бы коротко о основных модулях стандартной библиотеки по паре строк написать:!!!
#ЗАДАНИЯ
```python
# Создайте свой модуль и добавьте в него одну функцию и две переменных. Импортируйте функцию, а также только одну переменную.
# собственный модуль, файл Mymod.py c doctest:

#!/usr/bin/env python3
"""
>>> add(3,4)
7
"""
def add(a,b):
    return (a+b)
pi_short = 3.14
pi_long = 3.1415

if __name__ == "__main__":
    import doctest
    doctest.testmod()
    print ("all tests passed")
# использование: 
from Mymod import pi_short
from Mymod import add
print ("pi_incremented = ",add(pi_short,1))
```

#### 17 OOP  ####
#ТЕОРИЯ

В языке python все встроенные и библиотечные классы, а так же создаваеемые ими классы прямо или косвенно наследуют единный базовый класс object. В питоне утинная типизация, если нам необходимо вызвать определенный метод - неважно к какому классу относится объект  - главное чтобы он имел метод который мы хотим вызвать.
Чтобы создать класс необходимо использовать ключевое слово class. Далее внутри него можете прописать любые функции и переменные, которые только захотите.
После этого на основе какого-либо класса вы можете создать объект. Для этого используйте название класса для выделения памяти под объект.
```python
class Some:
    pass # Класс может ничего не возвращать

obj_new = Some() # Создание объекта
```
наследование говорит: что можно наследовать поля и методы
полиморфизм говорит: что можно переопределить унаследованные методы, полиморфизм является механизмом дополнительным к наследованию, повышающим его гибкость
Инкапсуляция позволяет нам ограничить доступ к какой-либо функции в классе. Благодаря этому злоумышленники или же мы сами не сможем случайно или намерено вызвать или изменить метод.
```python
class Some:
     def _printWords(self):
          print ("Попробуй меня вызвать")

obj = Some()
obj._printWords() # Вызов функции ничего не даст
```
При помощи двойного подчеркивания эффект защиты усиливается, поэтому вызвать функцию вообще будет невозможным.

Конструкторы позволяют задать некие характеристики для объекта сразу же при его создании. Чтобы создать конструктор необходимо использовать ключевое слово __init__.

super () - это обращение к методу в главном (супер) классе, используется если мы хотим переопределить метод

#ЗАДАНИЯ
```python
#!/usr/bin/env python3
#Создайте класс Автомобиль. В этом классе создайте несколько переменных,
# которые будут отвечать за характеристики автомобиля. 
#Создайте конструктор,  метод, который будет присваивать значения всем переменным и метод, который будет выводить все переменные на экран. Создайте два объекта и используйте оба метода для объектов.
#Создайте теперь класс Мотоцикл и сделайте его наследником класса Автомобиль. 
#Добавьте в него методы, а также свои собственные переменные. Создайте объект на основе нового класса и через этот объект обратитесь к методам главного класса Автомобиль.
#В классе Car есть метод get. Используйте полиморфизм чтобы переделать этот метод в классе наследнике. При вызове harley.get () должен выдаваться следующий текст: Транспорт  Harley Davidson  может ехать со скоростью  200  на всех  2  колесах!, moto engine is: Powerfull

class Car:
    color = 'black'
    def __init__(self, speed, mark):
        speed = 0
        mark = 'unknown'
    def set (self, speed, mark):
        self.speed = speed
        self.mark = mark
    def get (self):
        self.__protectedf()
        print ("speed = ", self.speed, ", mark =", self.mark, ", color = ", self.color)
    # пример инкапсуляции:
    def __protectedf(self):#в классе __ ок, вне класса _protecdedf - еще вызовется, __protectedf - выдает ошибку
        print ("protected finction was called")

lada = Car(9,'granta')
lada.set(10,'priora')
lada.get()
#lada.__protectedf()# AttributeError: 'Car' object has no attribute '__protectedf'

#пример наследования:
class Moto(Car):
    wheels = 3 # переменная уникальная для класса Moto
    engine = 'default'
    def have_stroler(self):
        if self.wheels == 3:
            return True
        else:
            return False
    def __init__(self, speed, mark, engine):
        self.engine = engine
        super().__init__(speed, mark) # без self!

    def get (self): #переопределяем метод, пример полиморфизма
        super().get()# super () - это обращение к главному классу
        print ("moto engine is:",self.engine)

yamaha = Moto(20,'vm', 'middle engine')
yamaha.set(250, 'vmmax')
yamaha.get()
yamaha.wheels = 4
print ("have stroler = ",yamaha.have_stroler())
```

#### 20 decorators ####

Для того, чтобы понять, как работают декораторы, в первую очередь следует вспомнить, что функции в python являются объектами, соответственно, их можно возвращать из другой функции или передавать в качестве аргумента. Также следует помнить, что функция в python может быть определена и внутри другой функции.

Вспомнив это, можно смело переходить к декораторам. Декораторы — это, по сути, "обёртки", которые дают нам возможность изменить поведение функции, не изменяя её код

Одну функцию можно оборачивать несколько раз:
```python
def decorator (func):
	def wrapper ():
		print ("Код до выполения функции")
		func ()
		print ("Код, который сработал после функции")
	return wrapper
	
def test (func):
	def wrapper ():
		print ("Код до выполения функции 2")
		func ()
		print ("Код, который сработал после функции 2")
	return wrapper

@decorator
@test
def show ():
	print ("Я обычная функция")
	
# show = decorator (show)
show ()
#OUTPUT
Код до выполения функции
Код до выполения функции 2
Я обычная функция
Код, который сработал после функции 2
Код, который сработал после функции

```
декорирование с параметрами:
```python
#!/usr/bin/env python3
#Создайте декоратор, который обернет функцию. Кроме того, добавьте в вашу простую функцию аргументы и сделайте так чтобы вы могли передавать их через декораторы.
def show_decorated_age(myfunk): # уменьшает возраст на три года
    def wrapper(age_y, age_m):
        age_y -= 3
        myfunk(age_y, age_m)
    return wrapper

@show_decorated_age
def show_age(age_y, age_m):
    print ("my age is {} years {} months".format(age_y, age_m))

show_age(32,6)
```
# TODO понять в чем выгода декораторов если перед декорированием мы приводим код декорируемой функции

Один из важных фактов, которые следует понимать, заключается в том, что функции и методы в Python — это практически одно и то же, за исключением того, что методы всегда ожидают первым параметром ссылку на сам объект (self). Это значит, что мы можем создавать декораторы для методов точно так же, как и для функций, просто не забывая про self.

